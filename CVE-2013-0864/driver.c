#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <unistd.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <fcntl.h>
#include <libavformat/avformat.h>
#include <libavcodec/avcodec.h>

#define DIE(...)    do { fprintf(stderr, __VA_ARGS__); exit(1); } while(0)

#ifndef SILENT
# define TRACE(...)     printf(__VA_ARGS__)
#else
# define TRACE(...)     (void)0
#endif

extern AVCodec ff_gif_decoder;
extern AVInputFormat ff_gif_demuxer;

struct buffer {
    uint8_t* data;
    size_t len;
    size_t pos;
};

struct buffer* load_file(const char* path) {
    int ret;

    struct stat st = {0};
    ret = stat(path, &st);
    if (ret < 0) {
        perror("stat");
    }

    struct buffer* buf = malloc(sizeof(struct buffer));
    buf->data = malloc(st.st_size);
    buf->len = 0;
    buf->pos = 0;

    int fd = open(path, O_RDONLY);
    if (fd < 0) {
        perror("open");
    }

    while (buf->len < st.st_size) {
        ret = read(fd, buf->data + buf->len, st.st_size - buf->len);
        if (ret < 0) {
            perror("read");
        }
        if (ret == 0) {
            DIE("unexpected EOF: expected %d more bytes\n",
                    st.st_size - buf->len);
        }
        buf->len += ret;
    }

    return buf;
}

int read_buffer(void* buffer_, uint8_t* buf, int buf_size) {
    struct buffer* buffer = buffer_;
    if (buf_size <= 0) {
        return 0;
    }
    size_t amt_max = buffer->len - buffer->pos;
    size_t amt = buf_size < amt_max ? buf_size : amt_max;
    memcpy(buf, buffer->data + buffer->pos, amt);
    TRACE("read %d at %d\n", amt, buffer->pos);
    buffer->pos += amt;
    return amt;
}

int64_t seek_buffer(void* buffer_, int64_t offset, int whence) {
    struct buffer* buffer = buffer_;
    TRACE("seek to %ld, %d\n", offset, whence);
    if (whence == AVSEEK_SIZE) {
        return buffer->len;
    }
    size_t base;
    switch (whence) {
        case SEEK_SET:
            base = 0;
            break;
        case SEEK_CUR:
            base = buffer->pos;
            break;
        case SEEK_END:
            base = buffer->len;
            break;
        default:
            fprintf(stderr, "bad arguments to seek: %ld, %d\n", offset, whence);
            return -1;
    }
    size_t new_pos = base + offset;
    if (new_pos > buffer->len) {
        return -1;
    }
    buffer->pos = new_pos;
    return buffer->pos;
}

int main(int argc, char *argv[]) {
    if (argc <= 1) {
        fprintf(stderr, "usage: %s <input file>\n", argv[0]);
        return 1;
    }

    av_register_all();
    avcodec_register_all();

    int ret;

    struct buffer* input = load_file(argv[1]);
    TRACE("read %d bytes from %s\n", input->len, argv[1]);

    AVIOContext* io = avio_alloc_context(
            av_malloc(4096),
            4096,
            0,
            input,
            read_buffer,
            NULL,
            seek_buffer);
    TRACE("io = %p\n", io);

    AVFormatContext* fcx = avformat_alloc_context();
    if (fcx == NULL) {
        DIE("error allocating avformat context\n");
    }
    fcx->pb = io;

    // TODO: hardcode the exact pointer &ff_gif_demuxer
    AVInputFormat* format = av_find_input_format("gif");
    TRACE("format = %p\n", format);
    ret = avformat_open_input(&fcx, "<dummy>", format, NULL);
    if (ret != 0) {
        DIE("error %d opening dummy input\n", ret);
    }

    AVCodec* codec = avcodec_find_decoder_by_name("gif");
    AVCodecContext* ccx = avcodec_alloc_context3(codec);
    ret = avcodec_open2(ccx, codec, NULL);
    if (ret < 0) {
        DIE("error opening codec: %d\n", ret);
    }

    AVPacket pkt;
    AVFrame* frame = avcodec_alloc_frame();
    int got_picture = 0;
    av_init_packet(&pkt);
    while (av_read_frame(fcx, &pkt) >= 0) {
        TRACE("got packet of size %d\n", pkt.size);
        ret = avcodec_decode_video2(ccx, frame, &got_picture, &pkt);
        if (ret < 0) {
            DIE("error decoding packet: %d\n", ret);
        }
        av_free_packet(&pkt);
    }


    return 0;
}
