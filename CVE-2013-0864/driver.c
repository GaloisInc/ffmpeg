#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <unistd.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <fcntl.h>
#include <libavformat/avformat.h>
#include <libavcodec/avcodec.h>
#include <fromager.h>

#ifndef SILENT
# define TRACE(...)     printf(__VA_ARGS__)
# define DIE(...)       do { fprintf(stderr, __VA_ARGS__); exit(1); } while(0)
#else
# define TRACE(...)     (void)0
# define DIE(...)       do { exit(1); } while(0)
#endif


extern AVCodec ff_gif_decoder;
extern AVInputFormat ff_gif_demuxer;

extern const uint8_t secret_file[256];
extern const size_t secret_file_len;

extern const uint8_t secret_packet_data[256];
extern const uint8_t secret_packet_lens[8];
extern const size_t secret_packet_count;

extern uint64_t heap_data[];
extern const size_t heap_len;
extern const void* heap_ptrs[];
void heap_do_relocs();

struct buffer {
    uint8_t* data;
    size_t len;
    size_t pos;
};

struct buffer* load_file(const char* path) {
    int ret;

    struct stat st = {0};
    ret = stat(path, &st);
    if (ret < 0) {
        perror("stat");
    }

    struct buffer* buf = malloc(sizeof(struct buffer));
    buf->data = malloc(st.st_size);
    buf->len = 0;
    buf->pos = 0;

    int fd = open(path, O_RDONLY);
    if (fd < 0) {
        perror("open");
    }

    while (buf->len < st.st_size) {
        ret = read(fd, buf->data + buf->len, st.st_size - buf->len);
        if (ret < 0) {
            perror("read");
        }
        if (ret == 0) {
            DIE("unexpected EOF: expected %d more bytes\n",
                    st.st_size - buf->len);
        }
        buf->len += ret;
    }

    return buf;
}

struct buffer* load_secret() {
    struct buffer* buf = malloc(sizeof(struct buffer));
    buf->data = secret_file;
    buf->len = secret_file_len;
    buf->pos = 0;
    return buf;
}

int read_buffer(void* buffer_, uint8_t* buf, int buf_size) {
    struct buffer* buffer = buffer_;
    if (buf_size <= 0) {
        return 0;
    }
    size_t amt_max = buffer->len - buffer->pos;
    size_t amt = buf_size < amt_max ? buf_size : amt_max;
    memcpy(buf, buffer->data + buffer->pos, amt);
    TRACE("read %d at %d\n", amt, buffer->pos);
    buffer->pos += amt;
    return amt;
}

int64_t seek_buffer(void* buffer_, int64_t offset, int whence) {
    struct buffer* buffer = buffer_;
    TRACE("seek to %ld, %d\n", offset, whence);
    if (whence == AVSEEK_SIZE) {
        return buffer->len;
    }
    size_t base;
    switch (whence) {
        case SEEK_SET:
            base = 0;
            break;
        case SEEK_CUR:
            base = buffer->pos;
            break;
        case SEEK_END:
            base = buffer->len;
            break;
        default:
            fprintf(stderr, "bad arguments to seek: %ld, %d\n", offset, whence);
            return -1;
    }
    size_t new_pos = base + offset;
    if (new_pos > buffer->len) {
        return -1;
    }
    buffer->pos = new_pos;
    return buffer->pos;
}

//#ifdef CC_MAKE_SNAPSHOT
void* __cc_heap_snapshot(size_t* len);
//#endif

#ifdef CC_USE_SNAPSHOT
//void __cc_heap_restore(void* buf, size_t len);
void __cc_malloc_init(void* start);
void* __cc_heap_get_start();
void __cc_heap_set_len(size_t len);
//# include "cc_snapshot.inc"
#endif

int main(int argc, char *argv[]) {
#ifdef CC_OFFLINE_DEMUX
    av_register_all();
    avcodec_register_all();

    int ret;

    //struct buffer* input = load_file(argv[1]);
    struct buffer* input = load_secret();
    TRACE("read %d bytes from %s\n", input->len, argv[1]);

    AVIOContext* io = avio_alloc_context(
            av_malloc(4096),
            4096,
            0,
            input,
            read_buffer,
            NULL,
            seek_buffer);
    TRACE("io = %p\n", io);

    AVFormatContext* fcx = avformat_alloc_context();
    if (fcx == NULL) {
        DIE("error allocating avformat context\n");
    }
    fcx->pb = io;

    AVInputFormat* format = &ff_gif_demuxer;
    TRACE("format = %p\n", format);
    ret = avformat_open_input(&fcx, "<dummy>", format, NULL);
    if (ret != 0) {
        DIE("error %d opening dummy input\n", ret);
    }

    AVPacket pkt;
    av_init_packet(&pkt);
    int fd = open("packets.dat", O_WRONLY | O_CREAT | O_TRUNC, 0644);
    while (av_read_frame(fcx, &pkt) >= 0) {
        TRACE("got packet of size %d\n", pkt.size);
        uint32_t size = pkt.size;
        write(fd, &size, 4);
        write(fd, pkt.data, size);

        av_free_packet(&pkt);
    }
    close(fd);

#else // CC_OFFLINE_DEMUX
    int ret;

    AVCodec* codec = &ff_gif_decoder;

#ifdef CC_OFFLINE_SNAPSHOT
    AVCodecContext* ccx = avcodec_alloc_context3(codec);
    ret = avcodec_open2(ccx, codec, NULL);
    if (ret < 0) {
        DIE("error opening codec: %d\n", ret);
    }

    AVFrame* frame = avcodec_alloc_frame();

    {
        size_t heap_len;
        void* heap = __cc_heap_snapshot(&heap_len);
        int fd = open("heap.dat", O_WRONLY | O_CREAT | O_TRUNC, 0644);
        write(fd, heap, heap_len);
        close(fd);

        void* ptrs[] = { ccx, frame };
        fd = open("heap-ptrs.dat", O_WRONLY | O_CREAT | O_TRUNC, 0644);
        write(fd, ptrs, sizeof(ptrs));
        close(fd);
    }

#else // CC_OFFLINE_SNAPSHOT

    heap_do_relocs();
    __cc_malloc_init_from_snapshot(heap_data, heap_len);
    AVCodecContext* ccx = heap_ptrs[0];
    AVFrame* frame = heap_ptrs[1];

#endif // CC_OFFLINE_SNAPSHOT

    AVPacket pkt;
    int got_picture = 0;
    size_t offset = 0;
    for (size_t i = 0; i < secret_packet_count; ++i) {
        size_t len = secret_packet_lens[i];
        __cc_valid_if(len <= sizeof(secret_packet_data) - offset,
            "packet length out of range");

        av_new_packet(&pkt, len);
        memcpy(pkt.data, secret_packet_data + offset, len);
        offset += len;

        TRACE("got packet of size %d\n", len);
        ret = avcodec_decode_video2(ccx, frame, &got_picture, &pkt);
        if (ret < 0) {
            DIE("error decoding packet: %d\n", ret);
        }
        av_free_packet(&pkt);
    }

#endif // CC_OFFLINE_DEMUX


    return 0;
}
