#!/usr/bin/env python3
import os
import struct
import subprocess
import sys
import time

MAX_LEN = 256
MAX_PACKET_COUNT = 8

time_str = time.strftime('%c')


def bytes_to_c(b, max_len, bytes_per_line=16):
    lines = []
    for i in range(0, max_len, bytes_per_line):
        s = ''
        for j in range(i, i + bytes_per_line):
            if j >= len(b):
                s += '0, '
            else:
                s += '0x%02x, ' % b[j]
        if s[-1] == ' ':
            s = s[:-1]
        lines.append('    ' + s)
    return lines

def words_to_c(b, bytes_per_line=32, prefix=''):
    lines = []
    for i in range(0, len(b), bytes_per_line):
        s = ''
        for j in range(i, i + bytes_per_line, 8):
            if j >= len(b):
                continue
            wb = b[j:j+8]
            if len(wb) < 8:
                wb += bytes(8 - len(wb))
            w, = struct.unpack('<Q', wb)
            s += '%s0x%016x, ' % (prefix, w)
        if s[-1] == ' ':
            s = s[:-1]
        lines.append('    ' + s)
    return lines

def ptrs_to_c(b, bytes_per_line=16):
    return words_to_c(b, bytes_per_line=bytes_per_line, prefix='(void*)')

def try_read(path):
    try:
        return open(path, 'rb').read()
    except:
        return b''


def do_file():
    gif_path = os.path.join(os.path.dirname(sys.argv[0]), 'tiny-exploit.gif')
    b = try_read(gif_path)
    assert len(b) <= MAX_LEN, 'tiny-exploit.gif is too large (%d bytes)' % len(b)

    print('// Auto-generated by gen_secrets.py at %s' % time_str)
    print('const uint8_t secret_file[%d] SECRET_GLOBAL = {' % MAX_LEN)
    print('\n'.join(bytes_to_c(b, MAX_LEN)))
    print('};')
    print('const size_t secret_file_len SECRET_GLOBAL = %d;' % len(b))

def packets(path):
    try:
        f = open(path, 'rb')
    except:
        return []
    pkts = []
    while True:
        b = f.read(4)
        if len(b) == 0:
            break
        assert len(b) == 4
        pkt_len, = struct.unpack('<I', b)
        pkts.append(f.read(pkt_len))
    return pkts

def do_packets():
    packet_path = os.path.join(os.path.dirname(sys.argv[0]), '..', 'packets.dat')
    pkts = packets(packet_path)
    b = b''.join(pkts)
    assert len(b) <= MAX_LEN, 'packets are too large (%d bytes)' % len(b)

    print('// Auto-generated by gen_secrets.py at %s' % time_str)
    print('const uint8_t secret_packet_data[%d] SECRET_GLOBAL = {' % MAX_LEN)
    print('\n'.join(bytes_to_c(b, MAX_LEN)))
    print('};')
    print('const uint8_t secret_packet_lens[%d] SECRET_GLOBAL = {' % MAX_PACKET_COUNT)
    print('\n'.join(bytes_to_c(bytes(len(pkt) for pkt in pkts), MAX_PACKET_COUNT, bytes_per_line=8)))
    print('};')
    print('const size_t secret_packet_count SECRET_GLOBAL = %d;' % len(pkts))


def symbols(path):
    p = subprocess.run(('nm', path), stdout=subprocess.PIPE, check=True)
    dct = {}
    for line in p.stdout.splitlines():
        parts = line.strip().split()
        if len(parts) != 3:
            continue
        name = parts[2].decode('utf-8')
        addr = int(parts[0], 16)
        dct[addr] = name
    return dct

def do_heap():
    heap_path = os.path.join(os.path.dirname(sys.argv[0]), '..', 'heap.dat')
    b = try_read(heap_path)
    heap_ptrs_path = os.path.join(os.path.dirname(sys.argv[0]), '..', 'heap-ptrs.dat')
    b2 = try_read(heap_ptrs_path)

    prog_path = os.path.join(os.path.dirname(sys.argv[0]), '..', 'driver')
    syms = symbols(prog_path)
    sym_start = min(syms.keys(), default=0)
    sym_end = max(syms.keys(), default=0) + 4096
    relocs = []
    seen_syms = set()
    for i in range(0, len(b) - 7, 8):
        val, = struct.unpack('<Q', b[i:i+8])
        if not sym_start <= val <= sym_end:
            continue
        key = max(k for k in syms.keys() if k <= val)
        offset = val - key

        name = syms[key]
        if name not in seen_syms:
            seen_syms.add(name)
            relocs.append('    extern %s;' % name)

        place = '(void*)heap_data + %d' % i
        addr = '(void*)&%s' % name
        if offset != 0:
            addr += ' + %d' % offset

        relocs.append('    CC_WRITE(%s, %s);' % (place, addr))

    print('// Auto-generated by gen_secrets.py at %s' % time_str)
    print('uint64_t heap_data[] HEAP_INIT = {')
    print('\n'.join(words_to_c(b)))
    print('};')
    print('const size_t heap_len = %d;' % len(b))
    print('const void* heap_ptrs[] = {')
    print('\n'.join(ptrs_to_c(b2)))
    print('};')
    print('void heap_do_relocs() {')
    print('    #define CC_WRITE(ptr, val) __cc_write_unchecked((uintptr_t*)(ptr), (uintptr_t)(val))')
    print('\n'.join(relocs))
    print('    #undef CC_WRITE')
    print('}')


if __name__ == '__main__':
    mode, = sys.argv[1:]
    if mode == 'file':
        do_file()
    elif mode == 'packets':
        do_packets()
    elif mode == 'heap':
        do_heap()
    else:
        raise ValueError('bad mode %r' % mode)
