CVE-2013-0864
=============

- Fixed in `c10350358da58600884292c08a8690289b81de29`
- https://www.cvedetails.com/cve/CVE-2013-0864/
- All commands are run from the top level directory of this repository.

Compile
-------

To compile on *Linux*, run the following:

```sh
LLVM_SUFFIX=-9 bash CVE-2013-0864/configure.sh
LLVM_SUFFIX=-9 DRIVER_CFLAGS='-DSILENT' bash CVE-2013-0864/build.sh
```

This will use the pregenerated versions of `driver_secret.c` and
`driver_heap.c` that are included in the repo.

Run `./driver` to obtain a function call trace, for comparison with the
MicroRAM execution.

### Regenerating `driver_secret.c`

```sh
python3 CVE-2013-0864/gen_secrets.py file
```

This will generate new values for `secret_file` and `secret_file_len` from the
contents of `CVE-2013-0864/tiny-exploit.gif`.  Paste the output of the
`gen_secrets` script into `driver_secret.c`, replacing the previous definitions
of `secret_file` and `secret_file_len` (but not the other definitions below
them).

Now run

```sh
LLVM_SUFFIX=-9 DRIVER_CFLAGS='-DCC_OFFLINE_DEMUX' bash CVE-2013-0864/build.sh
./driver    # Generates packets.dat
python3 CVE-2013-0864/gen_secrets.py packets
```

Paste the output of `gen_secrets` into `driver_secret.c`, replacing the
definitions of `secret_packet_data`, `secret_packet_lens`, and
`secret_packet_count`.

### Regenerating `driver_heap.c`

```sh
LLVM_SUFFIX=-9 DRIVER_CFLAGS='-DCC_OFFLINE_SNAPSHOT' bash CVE-2013-0864/build.sh
./driver    # Generates heap.dat and heap-ptrs.dat
python3 CVE-2013-0864/gen_secrets.py heap
```

Paste the output of `gen_secrets` into `driver_heap.c`, replacing all the
auto-generated definitions (starting at the line `// Auto-generated by
gen_secrets.py at ...`).

### Testing

To test the behavior of the driver, run:

```sh
LLVM_SUFFIX=-9 DEBUG=1 bash CVE-2013-0864/build.sh
./driver
```

This should output a few lines like `got packet of size 65`.


### macOS

*These instructions are out of date.*  At the very least, the extra configure
flags should be added to `configure.sh` so macOS can use the same `bash
CVE-2013-0864/configure.sh` command as on Linux.  But also, the `build.sh`
steps may not work any more, since they involve some tricky linking.

These are instructions for compiling on *OS X* with `llvm@9` installed via brew.

```
# Compiling with `clang -flto` produces LLVM bitcode instead of normal object files
./configure --disable-asm --disable-doc --cc='clang-9 -flto -isysroot /Library/Developer/CommandLineTools/SDKs/MacOSX.sdk' --cxx='clang++-9 -flto -isysroot /Library/Developer/CommandLineTools/SDKs/MacOSX.sdk' \
    --enable-small \
    --disable-everything --enable-protocol=file --enable-demuxer=gif --enable-decoder=gif \
    --enable-encoder=rawvideo --enable-muxer=null --disable-filter=null

LLVM_SUFFIX=-9 bash CVE-2013-0864/build.sh
```

Read a GIF
----------

Read in a GIF:

```
./driver CVE-2013-0864/jerry.gif
```

This runs the GIF decoder but simply discards the video stream.

Trigger vulnerability
---------------------

Trigger buffer overflow by attempting to read a bad GIF:

```
./driver CVE-2013-0864/payload.gif
```

This consistently triggers a segmentation fault on my system (OS X) when compiled with Apple LLVM version 10.0.1 (clang-1001.0.46.4).

Payload modified from [here](https://66.media.tumblr.com/5a646387587dd017f65b3742951670b3/tumblr_mjq8ocHhEE1rpur03o1_400.gifv).

The overflow occurs when a frame covers only part of the image and has its
disposal method set to "restore" (3).  In this case, the decoder copies the
portion of the main image data buffer (`s->picture`) that will be overwritten
by the frame into a secondary buffer (`s->stored_img`), draws the frame into
the main buffer, and afterward restores the previous contents by copying from
from the secondary buffer back into the main buffer.  The copies between the
main and secondary buffers both invoke the `gif_copy_img_rect` function,
passing the offset `(l, t)` (left/top) and size `(w, h)` of the frame; the
buffer overflow occurs inside that function.

Within `gif_copy_img_rect`, the overflow occurs due to incorrect computation of
an end pointer.  Given source buffer `src`, frame position `(l, t)` (left/top),
and frame size `(w, h)`, the function computes start and end pointers as
follows:
```C
// Current Y-pointer, which starts at `t` (top)
src_py = src + t * linesize;
// End Y-pointer; `b` stands for bottom
src_pb = src_py + t * linesize;
// BUG! Should be `h * linesize`, not `t * linesize`
```
It then loops until `src_py` is equal to `src_pb`.

The overflow can thus be triggered by a frame with disposal mode "restore" (3)
where `t > h`.

`tiny-exploit.gif` has two frames, of which the first has `t = 6` and `h = 2`
(`t > h`).  The file was created in GIMP and then modified as follows.  First,
find the first frame's duration field by looking for the bytes `7c 00` (124 in
decimal, which is the duration of the first frame in units of 0.01s).  The byte
immediately before the duration field contains the flags and disposal mode for
the frame.  Modify this byte to have the form `0bxxx0_11xx` (in this case, by
changing it from `09` to `0d`).  Now the frame has disposal mode "restore" (3)
and `t > h`, so it will trigger the overflow.

System calls
------------

Trace the system calls with the payload.

```
strace -o CVE-2013-0864/strace_out.txt -c -- ./driver CVE-2013-0864/payload.gif
```

