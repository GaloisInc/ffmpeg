CVE-2013-0864
=============

- Fixed in `c10350358da58600884292c08a8690289b81de29`
- https://www.cvedetails.com/cve/CVE-2013-0864/
- All commands are run from the top level directory of this repository.

Compile
-------

To compile on *linux*, run the following:

```
# Compiling with `clang -flto` produces LLVM bitcode instead of normal object files
./configure --disable-asm --disable-doc --cc='clang -flto' --cxx='clang++ -flto' \
    --enable-small \
    --disable-everything --enable-protocol=file --enable-demuxer=gif --enable-decoder=gif \
    --enable-encoder=rawvideo --enable-muxer=null --disable-filter=null

bash CVE-2013-0864/build.sh
```

The build process is described in more detail in `build.sh`.
These are instructions for compiling on *OS X* with `llvm@9` installed via brew.

```
# Compiling with `clang -flto` produces LLVM bitcode instead of normal object files
./configure --disable-asm --disable-doc --cc='clang-9 -flto -isysroot /Library/Developer/CommandLineTools/SDKs/MacOSX.sdk' --cxx='clang++-9 -flto -isysroot /Library/Developer/CommandLineTools/SDKs/MacOSX.sdk' \
    --enable-small \
    --disable-everything --enable-protocol=file --enable-demuxer=gif --enable-decoder=gif \
    --enable-encoder=rawvideo --enable-muxer=null --disable-filter=null

LLVM_SUFFIX=-9 bash CVE-2013-0864/build.sh
```

Read a GIF
----------

Read in a GIF:

```
./driver CVE-2013-0864/jerry.gif
```

This runs the GIF decoder but simply discards the video stream.

Trigger vulnerability
---------------------

Trigger buffer overflow by attempting to read a bad GIF:

```
./driver CVE-2013-0864/payload.gif
```

This consistently triggers a segmentation fault on my system (OS X) when compiled with Apple LLVM version 10.0.1 (clang-1001.0.46.4).

Payload modified from [here](https://66.media.tumblr.com/5a646387587dd017f65b3742951670b3/tumblr_mjq8ocHhEE1rpur03o1_400.gifv).

The overflow occurs when a frame covers only part of the image and has its
disposal method set to "restore" (3).  In this case, the decoder copies the
portion of the main image data buffer (`s->picture`) that will be overwritten
by the frame into a secondary buffer (`s->stored_img`), draws the frame into
the main buffer, and afterward restores the previous contents by copying from
from the secondary buffer back into the main buffer.  The copies between the
main and secondary buffers both invoke the `gif_copy_img_rect` function,
passing the offset `(l, t)` (left/top) and size `(w, h)` of the frame; the
buffer overflow occurs inside that function.

Within `gif_copy_img_rect`, the overflow occurs due to incorrect computation of
an end pointer.  Given source buffer `src`, frame position `(l, t)` (left/top),
and frame size `(w, h)`, the function computes start and end pointers as
follows:
```C
// Current Y-pointer, which starts at `t` (top)
src_py = src + t * linesize;
// End Y-pointer; `b` stands for bottom
src_pb = src + t * linesize;
// BUG! Should be `h * linesize`, not `t * linesize`
```
It then loops until `src_py` is equal to `src_pb`.

The overflow can thus be triggered by a frame with disposal mode "restore" (3)
where `t > h`.

`tiny-exploit.gif` has two frames, of which the first has `t = 6` and `h = 2`
(`t > h`).  The file was created in GIMP and then modified as follows.  First,
find the first frame's duration field by looking for the bytes `7c 00` (124 in
decimal, which is the duration of the first frame in units of 0.01s).  The byte
immediately before the duration field contains the flags and disposal mode for
the frame.  Modify this byte to have the form `0bxxx0_11xx` (in this case, by
changing it from `09` to `0d`).  Now the frame has disposal mode "restore" (3)
and `t > h`, so it will trigger the overflow.

System calls
------------

Trace the system calls with the payload.

```
strace -o CVE-2013-0864/strace_out.txt -c -- ./driver CVE-2013-0864/payload.gif
```

